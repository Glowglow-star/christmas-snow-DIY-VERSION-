<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Optimize viewport for mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Snowy Christmas Night | Interactive Art</title>
  
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  
  <style>
    /* --- Base Styles --- */
    :root {
      --glass-bg: rgba(16, 20, 30, 0.85);
      --glass-border: rgba(255, 255, 255, 0.12);
      --accent: #FFD700;
      --accent-blue: #60a5fa;
      --text-color: #F0F4F8;
    }

    body {
      margin: 0; padding: 0; background-color: #05070a;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden; 
      /* Flex centering for the whole page */
      display: flex; justify-content: center; align-items: center;
      /* Use dvh for better mobile browser support */
      height: 100vh; height: 100dvh; 
      color: var(--text-color); 
      user-select: none; -webkit-user-select: none; touch-action: none;
    }

    /* Canvas Container - Ensure Centering */
    #canvas-container {
      position: relative; 
      box-shadow: 0 0 80px rgba(0,0,0,0.8);
      overflow: hidden; line-height: 0;
      width: 100%; height: 100%;
      /* Centering the canvas element inside */
      display: flex; justify-content: center; align-items: center;
    }
    
    /* Ensure canvas behaves */
    canvas {
      display: block;
      margin: auto;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }
    
    @media (min-width: 768px) {
      #canvas-container {
        border-radius: 16px;
        max-width: 100vw; max-height: 100vh;
        width: auto; height: auto;
      }
    }

    /* --- Start Screen UI --- */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 8, 16, 0.92); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
      z-index: 100; display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      transition: opacity 0.8s ease-out;
      padding: 30px; box-sizing: border-box; text-align: center;
    }

    h1 {
      font-weight: 200; font-size: clamp(2rem, 5vw, 3rem); 
      letter-spacing: 3px; margin-bottom: 8px;
      background: linear-gradient(to bottom right, #fff, #a5b4fc);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(165, 180, 252, 0.3);
    }

    p.subtitle { 
      color: #94a3b8; margin-bottom: 40px; 
      font-size: 1rem; letter-spacing: 1px; font-weight: 300;
    }

    .btn-group { 
      display: flex; gap: 12px; flex-direction: column; 
      align-items: center; width: 100%; max-width: 320px; 
    }

    /* Enhanced Mobile Buttons */
    .ui-btn {
      position: relative;
      width: 100%; padding: 16px 24px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: white; border-radius: 16px;
      cursor: pointer; font-size: 16px; font-weight: 500; letter-spacing: 0.5px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex; align-items: center; justify-content: center; gap: 12px;
      backdrop-filter: blur(5px);
    }
    
    .ui-btn:active { transform: scale(0.98); background: rgba(255,255,255,0.08); }

    /* Accent Button (Select Image) */
    .upload-btn { 
      border-color: rgba(255, 215, 0, 0.3); 
      color: #ffeba0;
      background: rgba(255, 215, 0, 0.05);
    }

    /* Audio Button (Blueish) */
    .audio-btn {
      border-color: rgba(96, 165, 250, 0.3);
      color: #bfdbfe;
      background: rgba(96, 165, 250, 0.05);
    }

    /* Primary Button (Start) */
    #start-btn { 
      background: rgba(255, 255, 255, 0.9); 
      color: #0b1018; border: none;
      font-weight: 600; margin-top: 10px;
      opacity: 0.5; pointer-events: none;
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
    }
    #start-btn.ready { opacity: 1; pointer-events: auto; }

    #file-input, #audio-input { display: none; }
    
    .status-container {
      display: flex; flex-direction: column; gap: 4px;
      margin-bottom: 10px;
    }
    .file-status { font-size: 12px; color: #64748b; height: 16px; }

    /* --- In-App UI Overlays --- */
    #left-ui-container {
      position: absolute; top: max(20px, env(safe-area-inset-top)); left: 20px; z-index: 10;
      display: flex; flex-direction: column; gap: 10px;
      align-items: flex-start; pointer-events: none; 
    }
    
    @media (max-width: 600px) {
      #left-ui-container { transform: scale(0.9); transform-origin: top left; left: 16px; }
    }

    .status-badge {
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      padding: 6px 14px; border-radius: 20px; font-size: 12px;
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 8px; width: fit-content; pointer-events: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .dot { width: 6px; height: 6px; border-radius: 50%; background-color: #ef4444; transition: all 0.5s; }
    .dot.active { background-color: #4ade80; box-shadow: 0 0 6px #4ade80; }

    .hint-text {
      background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(255,255,255,0.1);
      padding: 8px 16px; border-radius: 20px; font-size: 13px; color: rgba(255,255,255,0.9);
      backdrop-filter: blur(4px); opacity: 0; transition: opacity 1s; margin-top: 5px;
    }

    /* --- Top Right Controls --- */
    #top-right-controls {
      position: absolute; top: max(20px, env(safe-area-inset-top)); right: 20px;
      z-index: 20; opacity: 0; transition: opacity 1s;
      display: flex; gap: 12px;
    }
    
    .icon-btn {
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      color: rgba(255,255,255,0.9); padding: 10px 16px; border-radius: 24px;
      cursor: pointer; font-size: 13px; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 6px; transition: all 0.2s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      font-weight: 500;
    }
    .icon-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.15); }
    .icon-btn.active { 
      background: rgba(255, 215, 0, 0.15); 
      border-color: rgba(255, 215, 0, 0.4); 
      color: #ffe066; 
    }
    #music-toggle.playing { color: #86efac; border-color: rgba(134, 239, 172, 0.3); background: rgba(134, 239, 172, 0.1); }

    /* --- Edit Mode Tooltips --- */
    #edit-tips {
      background: var(--glass-bg); color: #cbd5e1; padding: 16px; 
      border-radius: 16px; font-size: 12px; display: none; 
      pointer-events: auto; border: 1px solid var(--glass-border);
      box-shadow: 0 10px 40px rgba(0,0,0,0.4); margin-top: 12px;
    }
    .tips-container { display: flex; flex-direction: column; gap: 10px; align-items: flex-start; }
    .tip-item { display: flex; align-items: center; gap: 10px; }
    .key {
      color: var(--accent); font-weight: 700; font-size: 11px; 
      background: rgba(255, 215, 0, 0.1); padding: 3px 8px; border-radius: 6px;
      border: 1px solid rgba(255, 215, 0, 0.1); text-transform: uppercase;
    }

    .loader { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; display: none; margin-bottom: 30px; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <div id="canvas-container">
    
    <!-- Left UI -->
    <div id="left-ui-container">
      <div class="status-badge"><div class="dot" id="cam-dot"></div><span id="cam-status">Waiting for Camera...</span></div>
      <div class="status-badge"><div class="dot" id="model-dot"></div><span id="model-status">Loading AI...</span></div>
      <div id="hint-overlay" class="hint-text">âœ¨ Open your hand to summon snow âœ¨</div>
      
      <!-- Edit Instructions -->
      <div id="edit-tips">
        <div class="tips-container">
          <div class="tip-item"><span class="key">Drag</span> Move Window</div>
          <div class="tip-item"><span class="key">â†˜ Corner</span> Resize</div>
          <div class="tip-item"><span class="key">Double Tap</span> Add / Delete</div>
          <div class="tip-item"><span class="key">Hold</span> Toggle Shape</div>
        </div>
      </div>
    </div>

    <!-- Top Right Controls -->
    <div id="top-right-controls">
      <button id="music-toggle" class="icon-btn">
        <span>ðŸŽµ</span> BGM
      </button>
      <button id="edit-mode-btn" class="icon-btn">
        <span>ðŸ”§</span> Edit
      </button>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
      <h1>Silent Night</h1>
      <p class="subtitle">Interactive Christmas Experience</p>
      <div class="loader" id="loader"></div>
      
      <div class="btn-group" id="controls">
        <!-- Image Upload -->
        <label for="file-input" class="ui-btn upload-btn">
          <span>ðŸ“·</span> Select Image
        </label>
        <input type="file" id="file-input" accept="image/*">
        
        <!-- BGM Upload -->
        <label for="audio-input" class="ui-btn audio-btn">
          <span>ðŸŽµ</span> Select BGM (Optional)
        </label>
        <input type="file" id="audio-input" accept="audio/*">

        <div class="status-container">
          <div id="img-status" class="file-status">No image selected</div>
          <div id="audio-status" class="file-status">Using built-in music</div>
        </div>
        
        <button id="start-btn" class="ui-btn">Start</button>
      </div>
    </div>
  </div>

  <script>
    // --- Global Variables ---
    let handpose, video;
    let hands = [];
    let bgImage = null;
    let bgLoaded = false;
    let snowflakes = [], windows = [], stars = [];
    let isModelReady = false, isCamReady = false;
    
    // Audio
    let audioCtx; 
    let lastSoundTime = 0;
    let musicBox; // Procedural fallback
    let customBGM = null; // Uploaded BGM
    
    // Edit Mode
    let isEditing = false;
    let draggingWindow = null;
    let resizingWindow = null;
    let dragOffset = {x:0, y:0};
    let longPressTimer = null;

    // Config
    const CONFIG = { 
      maxSnowflakes: 120,
      openHandThreshold: 1.2,
      bgmVolume: 0.08
    };

    function setup() {
      // Setup with initial dimensions
      const cnv = createCanvas(window.innerWidth, window.innerHeight);
      cnv.parent('canvas-container');
      
      document.addEventListener('contextmenu', event => event.preventDefault());

      initWindows(); 
      initStars();
      
      musicBox = new MusicBox();
      
      noLoop();
      bindEvents();
    }

    function bindEvents() {
      const fileInput = document.getElementById('file-input');
      const audioInput = document.getElementById('audio-input');
      const imgStatus = document.getElementById('img-status');
      const audioStatus = document.getElementById('audio-status');
      const startBtn = document.getElementById('start-btn');
      const editBtn = document.getElementById('edit-mode-btn');
      const musicBtn = document.getElementById('music-toggle');

      editBtn.addEventListener('click', () => {
        isEditing = !isEditing;
        editBtn.classList.toggle('active');
        document.getElementById('edit-tips').style.display = isEditing ? 'block' : 'none';
        editBtn.innerHTML = isEditing ? "<span>âœ…</span> Done" : "<span>ðŸ”§</span> Edit";
      });

      // Music Toggle Logic
      musicBtn.addEventListener('click', () => {
        userStartAudio();
        if (customBGM) {
          if (customBGM.isPlaying()) {
            customBGM.pause();
            musicBtn.classList.remove('playing');
          } else {
            musicBox.stop();
            customBGM.loop();
            customBGM.setVolume(0.5); 
            musicBtn.classList.add('playing');
          }
        } else {
          if (!musicBox.isPlaying) {
            musicBox.play();
            musicBtn.classList.add('playing');
          } else {
            musicBox.stop();
            musicBtn.classList.remove('playing');
          }
        }
      });

      // Image Upload & Resize Logic
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          loadImage(url, (img) => {
            bgImage = img;
            bgLoaded = true;
            
            // Use window dimensions to calculate aspect ratio fit
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            
            // Fit logic: cover as much as possible but contain within screen
            const imgRatio = img.width / img.height;
            const screenRatio = screenW / screenH;
            
            let finalW, finalH;
            
            // If screen is wider than image (landscape screen, portrait image)
            if (screenRatio > imgRatio) {
                finalH = screenH;
                finalW = finalH * imgRatio;
            } else {
                // Screen is narrower than image (portrait screen, landscape image)
                finalW = screenW;
                finalH = finalW / imgRatio;
            }
            
            // Important: Resize canvas to the fitted image size
            // The CSS flexbox will center this canvas element
            resizeCanvas(finalW, finalH);

            initWindows(); 
            
            imgStatus.innerText = `Image: ${file.name}`;
            imgStatus.style.color = "#86efac";
            startBtn.classList.add('ready');
          });
        }
      });

      // Audio Upload
      audioInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          loadSound(url, (sound) => {
            customBGM = sound;
            audioStatus.innerText = `Music: ${file.name}`;
            audioStatus.style.color = "#93c5fd";
          });
        }
      });

      startBtn.classList.add('ready'); 
      startBtn.addEventListener('click', initializeApp);
    }

    async function initializeApp() {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      } catch(e) { console.log("Web Audio API Error"); }

      document.getElementById('controls').style.display = 'none';
      document.getElementById('loader').style.display = 'block';
      document.querySelector('#start-screen p').innerText = "Initializing...";

      try {
        const constraints = { video: { facingMode: "user" }, audio: false };
        video = createCapture(constraints, function(stream) {
          isCamReady = true;
          updateUIStatus('cam', true, "Camera Active");
        });
        
        if (video) {
            video.size(width, height);
            video.hide();
            
            handpose = ml5.handpose(video, () => {
                isModelReady = true;
                updateUIStatus('model', true, "AI Ready");
                
                const startScreen = document.getElementById('start-screen');
                startScreen.style.opacity = 0;
                setTimeout(() => startScreen.style.display = 'none', 800);
                
                document.getElementById('hint-overlay').style.opacity = 1;
                document.getElementById('top-right-controls').style.opacity = 1;
                loop();
            });
            handpose.on("predict", results => hands = results);
        } else { 
          alert("Camera access failed. Ensure HTTPS."); 
        }
      } catch (err) { console.error(err); alert("Error: " + err.message); }
    }

    // --- Music Box ---
    class MusicBox {
      constructor() {
        this.osc = new p5.Oscillator('sine'); 
        this.env = new p5.Envelope();
        this.env.setADSR(0.2, 0.3, 0.1, 0.8); 
        this.env.setRange(CONFIG.bgmVolume, 0);
        
        this.osc.start();
        this.osc.amp(0);
        
        this.isPlaying = false;
        this.currentNote = 0;
        this.bpm = 75; 
        this.nextNoteTime = 0;
        
        this.melody = [
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }, 
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }, 
          { n: 587.33, d: 2.0 }, { n: 587.33, d: 1.0 }, { n: 493.88, d: 3.0 }, 
          { n: 523.25, d: 2.0 }, { n: 523.25, d: 1.0 }, { n: 392.00, d: 3.0 }, 
          { n: 440.00, d: 2.0 }, { n: 440.00, d: 1.0 }, { n: 523.25, d: 1.5 }, { n: 493.88, d: 0.5 }, { n: 440.00, d: 1.0 },
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }
        ];
      }
      
      play() {
        this.isPlaying = true;
        this.currentNote = 0;
        this.nextNoteTime = millis();
        this.osc.amp(0); 
      }
      
      stop() {
        this.isPlaying = false;
        this.osc.amp(0);
      }
      
      update() {
        if (!this.isPlaying) return;
        if (millis() >= this.nextNoteTime) {
          let note = this.melody[this.currentNote];
          this.osc.freq(note.n + random(-1, 1));
          this.env.play(this.osc, 0, 0.1);
          let durationMs = note.d * (60000 / this.bpm);
          this.nextNoteTime = millis() + durationMs;
          this.currentNote++;
          if (this.currentNote >= this.melody.length) this.currentNote = 0;
        }
      }
    }

    // --- Crisp & Quiet Light Sound ---
    function playMagicSound() {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      if (millis() - lastSoundTime < 150) return;
      lastSoundTime = millis();

      const now = audioCtx.currentTime;
      const baseFreq = 1046.50; 
      const ratios = [1, 1.5]; 
      
      ratios.forEach((ratio, index) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sine';
        
        const noteFreq = baseFreq * ratio;
        osc.frequency.setValueAtTime(noteFreq, now + index * 0.05); 

        const startTime = now + index * 0.05;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.05, startTime + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.5); 

        osc.start(startTime);
        osc.stop(startTime + 0.5);
      });
    }

    function draw() {
      background(11, 16, 24);
      
      if (bgLoaded && bgImage) {
        try { image(bgImage, 0, 0, width, height); } catch(e) { drawProceduralBackground(); }
      } else { drawProceduralBackground(); }

      if(musicBox) musicBox.update();

      updateWindows();

      if (!isEditing) {
        handleHandInteraction();
        updateSnowflakes();
      } else {
        fill(0, 100); rect(0,0,width,height);
        fill(255, 200); noStroke(); textAlign(CENTER); textSize(14);
        text("Edit Mode Active", width/2, 40);
      }
    }

    // --- Logic ---
    function handleHandInteraction() {
      if (hands.length > 0 && video && video.width) {
        const hand = hands[0];
        if (!isHandOpen(hand)) return; 

        let rawX = (hand.landmarks[5][0] + hand.landmarks[17][0]) / 2;
        let rawY = (hand.landmarks[5][1] + hand.landmarks[17][1]) / 2;
        let x = map(rawX, 0, video.width, width, 0); 
        let y = map(rawY, 0, video.height, 0, height);
        
        drawMagicCursor(x, y);
        if (frameCount % 4 === 0) {
          const count = floor(random(2, 5));
          for (let i = 0; i < count; i++) snowflakes.push(new Snowflake(x, y));
        }
      }
    }

    function isHandOpen(hand) {
      const landmarks = hand.landmarks;
      const dist = (p1, p2) => Math.sqrt(Math.pow(p1[0]-p2[0], 2) + Math.pow(p1[1]-p2[1], 2));
      const wrist = landmarks[0];
      const middleTip = landmarks[12];
      const middleBase = landmarks[9];
      return (dist(wrist, middleTip) / dist(wrist, middleBase)) > CONFIG.openHandThreshold;
    }

    function drawMagicCursor(x, y) {
      push(); translate(x, y); noStroke();
      fill(255, 215, 0, 20); circle(0, 0, 50);
      fill(255, 255, 200); circle(0, 0, 6);
      pop();
    }

    // --- Inputs ---
    function mousePressed() { handleInputStart(mouseX, mouseY); }
    function touchStarted() { if (touches.length > 0) handleInputStart(touches[0].x, touches[0].y); }

    function handleInputStart(mx, my) {
      if (!isEditing) return;
      
      longPressTimer = setTimeout(() => {
        for (let w of windows) {
          if (w.contains(mx, my)) { w.toggleShape(); break; }
        }
      }, 600); 

      for (let w of windows) {
        if (w.isCornerHover(mx, my)) { resizingWindow = w; return; }
      }
      for (let i = windows.length - 1; i >= 0; i--) {
        let w = windows[i];
        if (w.contains(mx, my)) {
          if (mouseButton === RIGHT) { w.toggleShape(); return; }
          draggingWindow = w; dragOffset.x = mx - w.getPixelX(); dragOffset.y = my - w.getPixelY(); return;
        }
      }
    }

    function mouseDragged() { handleInputMove(mouseX, mouseY); }
    function touchMoved() { 
      if (touches.length > 0) handleInputMove(touches[0].x, touches[0].y); 
      return false; 
    }

    function handleInputMove(mx, my) {
      if (!isEditing) return;
      if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }

      if (resizingWindow) {
        let newW = mx - resizingWindow.getPixelX();
        let newH = my - resizingWindow.getPixelY();
        resizingWindow.setPixelSize(max(10, newW), max(10, newH));
      } else if (draggingWindow) {
        draggingWindow.setPixelPos(mx - dragOffset.x, my - dragOffset.y);
      }
    }

    function mouseReleased() { clearInput(); }
    function touchEnded() { clearInput(); }
    
    function clearInput() {
      draggingWindow = null; resizingWindow = null;
      if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    }
    
    function doubleClicked() { handleDoubleInput(mouseX, mouseY); }
    function handleDoubleInput(mx, my) {
      if (!isEditing) return;
      for (let i = windows.length - 1; i >= 0; i--) {
        if (windows[i].contains(mx, my)) { windows.splice(i, 1); return; }
      }
      windows.push(new Window(mx/width, my/height, 0.08, 0.08));
    }

    // --- Classes ---
    class Window {
      constructor(nx, ny, nw, nh) {
        this.nx = nx; this.ny = ny; this.nw = nw; this.nh = nh;
        this.brightness = 0; this.state = 'IDLE'; this.timer = 0; this.shape = 'RECT'; 
      }
      getPixelX() { return this.nx * width; }
      getPixelY() { return this.ny * height; }
      getPixelW() { return this.nw * width; }
      getPixelH() { return this.nh * height; }
      setPixelPos(px, py) { this.nx = px / width; this.ny = py / height; }
      setPixelSize(pw, ph) { this.nw = pw / width; this.nh = ph / height; }
      toggleShape() { this.shape = (this.shape === 'RECT') ? 'CIRCLE' : 'RECT'; }
      contains(px, py) {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        return px > x && px < x + w && py > y && py < y + h;
      }
      isCornerHover(px, py) {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        return dist(px, py, x + w, y + h) < 25; 
      }
      trigger() {
        if (this.state === 'IDLE' || this.state === 'FADING') {
          this.state = 'TRIGGERED'; this.timer = 0; playMagicSound();
        }
      }
      update() {
        if(isEditing) { this.brightness = 0.5; return; }
        this.timer++;
        switch (this.state) {
          case 'IDLE': this.brightness = 0; break;
          case 'TRIGGERED':
            this.brightness = min(1, this.timer / 60); 
            if (this.brightness >= 1) { this.state = 'SUSTAIN'; this.timer = 0; }
            break;
          case 'SUSTAIN':
            this.brightness = 1; if (this.timer > 60) { this.state = 'FADING'; this.timer = 0; }
            break;
          case 'FADING':
            this.brightness = max(0, 1 - this.timer / 30); if (this.brightness <= 0) this.state = 'IDLE';
            break;
        }
      }
      display() {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        
        if (isEditing) {
          stroke(255, 200); strokeWeight(1); fill(255, 200, 100, 50);
          if (this.shape === 'CIRCLE') {
             rect(x, y, w, h); 
             fill(255, 220, 100, 150); 
             ellipse(x + w/2, y + h/2, w, h); 
          } else { rect(x, y, w, h); }
          noStroke(); fill(255); circle(x + w, y + h, 12); return;
        }

        // --- SOFT GLOW RENDERING ---
        if (this.brightness > 0.01) {
          push();
          // Use ADD blending for intense, accumulating light
          blendMode(ADD);
          
          const alpha = this.brightness * 255;
          const cx = x + w/2; const cy = y + h/2;
          
          noStroke();
          
          // 1. Wide Ambient Glow (Large blur, low opacity)
          drawingContext.filter = 'blur(30px)'; // Large blur for halo
          fill(255, 160, 50, alpha * 0.5);
          if (this.shape === 'CIRCLE') ellipse(cx, cy, w*1.5, h*1.5);
          else rect(x - w*0.25, y - h*0.25, w*1.5, h*1.5);

          // 2. Soft Light Body (Medium blur)
          drawingContext.filter = 'blur(10px)';
          fill(255, 200, 100, alpha * 0.8);
          if (this.shape === 'CIRCLE') ellipse(cx, cy, w*1.1, h*1.1);
          else rect(x - w*0.05, y - h*0.05, w*1.1, h*1.1);

          // 3. Bright Core (Low blur, high opacity, brighter color)
          drawingContext.filter = 'blur(4px)';
          fill(255, 255, 200, alpha);
          if (this.shape === 'CIRCLE') ellipse(cx, cy, w*0.8, h*0.8);
          else rect(x + w*0.1, y + h*0.1, w*0.8, h*0.8); 

          pop();
        }
      }
    }

    class Snowflake {
      constructor(x, y) {
        this.x = x + random(-10, 10); this.y = y;
        this.vx = random(-1, 1); this.vy = random(1, 3);
        this.size = random(2, 5); this.alpha = random(150, 255);
        this.active = true; this.wobble = random(100);
      }
      update() {
        this.wobble += 0.05; this.vx += sin(this.wobble) * 0.05;
        this.y += this.vy; this.x += this.vx;
        for (let w of windows) { if (w.contains(this.x, this.y)) { w.trigger(); this.active = false; return; } }
        if (this.y > height || this.x < 0 || this.x > width) this.active = false;
      }
      display() { noStroke(); fill(255, this.alpha); circle(this.x, this.y, this.size); }
    }

    function updateWindows() { windows.forEach(w => { w.update(); w.display(); }); }
    function updateSnowflakes() {
      for (let i = snowflakes.length - 1; i >= 0; i--) {
        snowflakes[i].update(); snowflakes[i].display();
        if (!snowflakes[i].active) snowflakes.splice(i, 1);
      }
      if (snowflakes.length > CONFIG.maxSnowflakes) snowflakes.splice(0, snowflakes.length - CONFIG.maxSnowflakes);
    }

    function initWindows() {
      windows = [
        new Window(0.15, 0.6, 0.03, 0.04), new Window(0.2, 0.6, 0.03, 0.04),
        new Window(0.35, 0.7, 0.04, 0.05), new Window(0.42, 0.7, 0.04, 0.05), 
        new Window(0.78, 0.75, 0.04, 0.05)
      ];
    }

    function initStars() { for(let i=0; i<80; i++) stars.push({x: random(2000), y: random(1000), s: random(1, 3), a: random(100, 255)}); }
    function drawProceduralBackground() {
      for (let y = 0; y < height; y++) {
        let c = lerpColor(color(10, 15, 30), color(40, 50, 80), map(y, 0, height, 0, 1));
        stroke(c); line(0, y, width, y);
      }
      noStroke();
      stars.forEach(s => { fill(255, s.a); circle(s.x % width, s.y % height, s.s); });
      fill(15, 20, 30); beginShape();
      vertex(0, height); vertex(0, height*0.7); vertex(width*0.5, height*0.8); vertex(width, height*0.75); vertex(width, height);
      endShape(CLOSE);
    }

    function updateUIStatus(id, active, text) {
      document.getElementById(`${id}-dot`).classList.toggle('active', active);
      document.getElementById(`${id}-status`).innerText = text;
    }
  </script>
</body>
</html>
