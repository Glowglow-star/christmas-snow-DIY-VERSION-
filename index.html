<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Optimize viewport for mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Snowy Christmas Night | Interactive Art</title>
  
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  
  <style>
    /* --- Base Styles --- */
    :root {
      --glass-bg: rgba(16, 20, 30, 0.85);
      --glass-border: rgba(255, 255, 255, 0.12);
      --accent: #FFD700;
      --accent-blue: #60a5fa;
      --text-color: #F0F4F8;
    }

    body {
      margin: 0; padding: 0; background-color: #05070a;
      /* Deep gradient background for better atmosphere */
      background: radial-gradient(circle at center, #1a1f2e 0%, #05070a 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden; 
      display: flex; 
      justify-content: center; 
      align-items: center;
      height: 100vh; 
      color: var(--text-color); 
      user-select: none; -webkit-user-select: none; touch-action: none;
    }

    /* Canvas Container - The "Card" */
    #canvas-container {
      position: relative; 
      /* Enhanced shadow for depth ("Expensive" look) */
      box-shadow: 0 20px 80px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.1);
      border-radius: 16px; /* Always rounded, even on mobile */
      overflow: hidden; 
      line-height: 0;
      /* Allow container to shrink to canvas size */
      width: auto; 
      height: auto;
      /* Prevent it from being larger than screen with some padding */
      max-width: 100vw; 
      max-height: 100vh;
      background: #000; /* Fallback */
    }
    
    /* Ensure canvas acts as a block to fill container correctly */
    canvas {
      display: block;
    }

    @media (min-width: 768px) {
      #canvas-container {
        border-radius: 20px;
        /* Add slight margin on desktop */
        max-width: 95vw; 
        max-height: 95vh;
      }
    }

    /* --- Start Screen UI --- */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 8, 16, 0.85); 
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      z-index: 100; display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      transition: opacity 0.8s ease-out;
      padding: 30px; box-sizing: border-box; text-align: center;
    }

    h1 {
      font-weight: 200; font-size: clamp(2rem, 5vw, 3rem); 
      letter-spacing: 3px; margin-bottom: 8px;
      background: linear-gradient(to bottom right, #fff, #a5b4fc);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(165, 180, 252, 0.3);
    }

    p.subtitle { 
      color: #94a3b8; margin-bottom: 40px; 
      font-size: 1rem; letter-spacing: 1px; font-weight: 300;
    }

    .btn-group { 
      display: flex; gap: 12px; flex-direction: column; 
      align-items: center; width: 100%; max-width: 320px; 
    }

    /* Enhanced Mobile Buttons */
    .ui-btn {
      position: relative;
      width: 100%; padding: 16px 24px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white; border-radius: 16px;
      cursor: pointer; font-size: 16px; font-weight: 500; letter-spacing: 0.5px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex; align-items: center; justify-content: center; gap: 12px;
      backdrop-filter: blur(5px);
    }
    
    .ui-btn:active { transform: scale(0.98); background: rgba(255,255,255,0.08); }

    /* Accent Button (Select Image) */
    .upload-btn { 
      border-color: rgba(255, 215, 0, 0.2); 
      color: #ffeba0;
      background: rgba(255, 215, 0, 0.05);
    }

    /* Audio Button (Blueish) */
    .audio-btn {
      border-color: rgba(96, 165, 250, 0.2);
      color: #bfdbfe;
      background: rgba(96, 165, 250, 0.05);
    }

    /* Primary Button (Start) */
    #start-btn { 
      background: rgba(255, 255, 255, 0.95); 
      color: #0b1018; border: none;
      font-weight: 600; margin-top: 10px;
      opacity: 0.5; pointer-events: none;
      box-shadow: 0 0 25px rgba(255, 255, 255, 0.15);
    }
    #start-btn.ready { opacity: 1; pointer-events: auto; }

    #file-input, #audio-input { display: none; }
    
    .status-container {
      display: flex; flex-direction: column; gap: 4px;
      margin-bottom: 10px;
    }
    .file-status { font-size: 12px; color: #64748b; height: 16px; }

    /* --- In-App UI Overlays --- */
    #left-ui-container {
      position: absolute; top: 20px; left: 20px; z-index: 10;
      display: flex; flex-direction: column; gap: 10px;
      align-items: flex-start; pointer-events: none; 
    }
    
    @media (max-width: 600px) {
      #left-ui-container { transform: scale(0.9); transform-origin: top left; left: 16px; top: 16px; }
    }

    .status-badge {
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      padding: 6px 14px; border-radius: 20px; font-size: 12px;
      backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 8px; width: fit-content; pointer-events: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .dot { width: 6px; height: 6px; border-radius: 50%; background-color: #ef4444; transition: all 0.5s; }
    .dot.active { background-color: #4ade80; box-shadow: 0 0 6px #4ade80; }

    .hint-text {
      background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255,255,255,0.15);
      padding: 8px 16px; border-radius: 20px; font-size: 13px; color: rgba(255,255,255,0.95);
      backdrop-filter: blur(8px); opacity: 0; transition: opacity 1s; margin-top: 5px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    /* --- Top Right Controls --- */
    #top-right-controls {
      position: absolute; top: 20px; right: 20px;
      z-index: 20; opacity: 0; transition: opacity 1s;
      display: flex; gap: 12px;
    }
    @media (max-width: 600px) {
      #top-right-controls { top: 16px; right: 16px; transform: scale(0.9); transform-origin: top right; }
    }
    
    .icon-btn {
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      color: rgba(255,255,255,0.9); padding: 10px 16px; border-radius: 24px;
      cursor: pointer; font-size: 13px; backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 6px; transition: all 0.2s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      font-weight: 500;
    }
    .icon-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.15); }
    .icon-btn.active { 
      background: rgba(255, 215, 0, 0.15); 
      border-color: rgba(255, 215, 0, 0.4); 
      color: #ffe066; 
    }
    #music-toggle.playing { color: #86efac; border-color: rgba(134, 239, 172, 0.3); background: rgba(134, 239, 172, 0.1); }

    /* --- Edit Mode Tooltips --- */
    #edit-tips {
      background: var(--glass-bg); color: #cbd5e1; padding: 16px; 
      border-radius: 16px; font-size: 12px; display: none; 
      pointer-events: auto; border: 1px solid var(--glass-border);
      box-shadow: 0 10px 40px rgba(0,0,0,0.4); margin-top: 12px;
    }
    .tips-container { display: flex; flex-direction: column; gap: 10px; align-items: flex-start; }
    .tip-item { display: flex; align-items: center; gap: 10px; }
    .key {
      color: var(--accent); font-weight: 700; font-size: 11px; 
      background: rgba(255, 215, 0, 0.1); padding: 3px 8px; border-radius: 6px;
      border: 1px solid rgba(255, 215, 0, 0.1); text-transform: uppercase;
    }

    .loader { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; display: none; margin-bottom: 30px; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <div id="canvas-container">
    
    <!-- Left UI -->
    <div id="left-ui-container">
      <div class="status-badge"><div class="dot" id="cam-dot"></div><span id="cam-status">Waiting for Camera...</span></div>
      <div class="status-badge"><div class="dot" id="model-dot"></div><span id="model-status">Loading AI...</span></div>
      <div id="hint-overlay" class="hint-text">âœ¨ Open your hand to summon snow âœ¨</div>
      
      <!-- Edit Instructions -->
      <div id="edit-tips">
        <div class="tips-container">
          <div class="tip-item"><span class="key">Pinch / Wheel</span> Zoom</div>
          <div class="tip-item"><span class="key">Drag Empty</span> Pan</div>
          <div class="tip-item"><span class="key">Drag Box</span> Move</div>
          <div class="tip-item"><span class="key">Double Tap</span> Add/Del</div>
        </div>
      </div>
    </div>

    <!-- Top Right Controls -->
    <div id="top-right-controls">
      <button id="music-toggle" class="icon-btn">
        <span>ðŸŽµ</span> BGM
      </button>
      <button id="edit-mode-btn" class="icon-btn">
        <span>ðŸ”§</span> Edit
      </button>
    </div>

    <!-- Start Screen -->
    <div id="start-screen">
      <h1>Silent Night</h1>
      <p class="subtitle">Interactive Christmas Experience</p>
      <div class="loader" id="loader"></div>
      
      <div class="btn-group" id="controls">
        <!-- Image Upload -->
        <label for="file-input" class="ui-btn upload-btn">
          <span>ðŸ“·</span> Select Image
        </label>
        <input type="file" id="file-input" accept="image/*">
        
        <!-- BGM Upload -->
        <label for="audio-input" class="ui-btn audio-btn">
          <span>ðŸŽµ</span> Select BGM (Optional)
        </label>
        <input type="file" id="audio-input" accept="audio/*">

        <div class="status-container">
          <div id="img-status" class="file-status">No image selected</div>
          <div id="audio-status" class="file-status">Using built-in music</div>
        </div>
        
        <button id="start-btn" class="ui-btn">Start</button>
      </div>
    </div>
  </div>

  <script>
    // --- Global Variables ---
    let handpose, video;
    let hands = [];
    let bgImage = null;
    let bgLoaded = false;
    let snowflakes = [], windows = [], stars = [];
    let isModelReady = false, isCamReady = false;
    
    // Audio
    let audioCtx; 
    let lastSoundTime = 0;
    let musicBox; // Procedural fallback
    let customBGM = null; // Uploaded BGM
    
    // Edit Mode & View Transformation
    let isEditing = false;
    let draggingWindow = null;
    let resizingWindow = null;
    let draggingView = false;
    
    // Viewport transform (Pan/Zoom)
    let view = { x: 0, y: 0, scale: 1, minScale: 0.5, maxScale: 4.0 };
    let dragStart = { x: 0, y: 0 }; // for view panning
    let dragOffset = { x: 0, y: 0 }; // for window dragging
    let prevPinchDist = -1; // for pinch zoom
    let longPressTimer = null;

    // Config
    const CONFIG = { 
      maxSnowflakes: 120,
      openHandThreshold: 1.2,
      bgmVolume: 0.08
    };

    function setup() {
      // Initialize with full window size first
      const screenW = window.innerWidth;
      const screenH = window.innerHeight;
      
      const cnv = createCanvas(screenW, screenH);
      cnv.parent('canvas-container');
      
      document.addEventListener('contextmenu', event => event.preventDefault());

      initWindows(); 
      initStars();
      
      musicBox = new MusicBox();
      
      noLoop();
      bindEvents();
    }

    function bindEvents() {
      const fileInput = document.getElementById('file-input');
      const audioInput = document.getElementById('audio-input');
      const imgStatus = document.getElementById('img-status');
      const audioStatus = document.getElementById('audio-status');
      const startBtn = document.getElementById('start-btn');
      const editBtn = document.getElementById('edit-mode-btn');
      const musicBtn = document.getElementById('music-toggle');

      editBtn.addEventListener('click', () => {
        isEditing = !isEditing;
        editBtn.classList.toggle('active');
        document.getElementById('edit-tips').style.display = isEditing ? 'block' : 'none';
        editBtn.innerHTML = isEditing ? "<span>âœ…</span> Done" : "<span>ðŸ”§</span> Edit";
        
        // Reset view when exiting edit mode
        if (!isEditing) {
          view = { x: 0, y: 0, scale: 1, minScale: 0.5, maxScale: 4.0 };
        }
      });

      // Music Toggle Logic (Custom vs Procedural)
      musicBtn.addEventListener('click', () => {
        userStartAudio();
        
        // Check if we are using Custom BGM or MusicBox
        if (customBGM) {
          // Handling Custom BGM
          if (customBGM.isPlaying()) {
            customBGM.pause();
            musicBtn.classList.remove('playing');
          } else {
            // Stop procedural if running
            musicBox.stop();
            customBGM.loop();
            customBGM.setVolume(0.5); // Default volume for MP3s
            musicBtn.classList.add('playing');
          }
        } else {
          // Handling Procedural BGM
          if (!musicBox.isPlaying) {
            musicBox.play();
            musicBtn.classList.add('playing');
          } else {
            musicBox.stop();
            musicBtn.classList.remove('playing');
          }
        }
      });

      // Image Upload with Center Fit Logic
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          loadImage(url, (img) => {
            bgImage = img;
            bgLoaded = true;
            
            // Get current viewport size (Max available)
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            
            // Calculate scale to fit comfortably within screen (leave 5% margin)
            const scaleW = (screenW * 0.95) / img.width;
            const scaleH = (screenH * 0.95) / img.height;
            const scale = Math.min(scaleW, scaleH);
            
            const finalW = img.width * scale;
            const finalH = img.height * scale;
            
            resizeCanvas(finalW, finalH);

            initWindows(); 
            
            imgStatus.innerText = `Image: ${file.name}`;
            imgStatus.style.color = "#86efac";
            startBtn.classList.add('ready');
          });
        }
      });

      // Audio Upload
      audioInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          // p5.sound loadSound can take a File object or URL
          const url = URL.createObjectURL(file);
          loadSound(url, (sound) => {
            customBGM = sound;
            audioStatus.innerText = `Music: ${file.name}`;
            audioStatus.style.color = "#93c5fd";
          });
        }
      });

      startBtn.classList.add('ready'); 
      startBtn.addEventListener('click', initializeApp);
    }

    async function initializeApp() {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      } catch(e) { console.log("Web Audio API Error"); }

      document.getElementById('controls').style.display = 'none';
      document.getElementById('loader').style.display = 'block';
      document.querySelector('#start-screen p').innerText = "Initializing...";

      try {
        const constraints = { video: { facingMode: "user" }, audio: false };
        video = createCapture(constraints, function(stream) {
          isCamReady = true;
          updateUIStatus('cam', true, "Camera Active");
        });
        
        if (video) {
            video.size(width, height);
            video.hide();
            
            handpose = ml5.handpose(video, () => {
                isModelReady = true;
                updateUIStatus('model', true, "AI Ready");
                
                const startScreen = document.getElementById('start-screen');
                startScreen.style.opacity = 0;
                setTimeout(() => startScreen.style.display = 'none', 800);
                
                document.getElementById('hint-overlay').style.opacity = 1;
                document.getElementById('top-right-controls').style.opacity = 1;
                loop();
            });
            handpose.on("predict", results => hands = results);
        } else { 
          alert("Camera access failed. Ensure HTTPS."); 
        }
      } catch (err) { console.error(err); alert("Error: " + err.message); }
    }

    // --- Soothing Procedural Music Box ---
    class MusicBox {
      constructor() {
        this.osc = new p5.Oscillator('sine'); 
        this.env = new p5.Envelope();
        this.env.setADSR(0.2, 0.3, 0.1, 0.8); 
        this.env.setRange(CONFIG.bgmVolume, 0);
        
        this.osc.start();
        this.osc.amp(0);
        
        this.isPlaying = false;
        this.currentNote = 0;
        this.bpm = 75; 
        this.nextNoteTime = 0;
        
        this.melody = [
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }, 
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }, 
          { n: 587.33, d: 2.0 }, { n: 587.33, d: 1.0 }, { n: 493.88, d: 3.0 }, 
          { n: 523.25, d: 2.0 }, { n: 523.25, d: 1.0 }, { n: 392.00, d: 3.0 }, 
          { n: 440.00, d: 2.0 }, { n: 440.00, d: 1.0 }, { n: 523.25, d: 1.5 }, { n: 493.88, d: 0.5 }, { n: 440.00, d: 1.0 },
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }
        ];
      }
      
      play() {
        this.isPlaying = true;
        this.currentNote = 0;
        this.nextNoteTime = millis();
        this.osc.amp(0); 
      }
      
      stop() {
        this.isPlaying = false;
        this.osc.amp(0);
      }
      
      update() {
        if (!this.isPlaying) return;
        if (millis() >= this.nextNoteTime) {
          let note = this.melody[this.currentNote];
          this.osc.freq(note.n + random(-1, 1));
          this.env.play(this.osc, 0, 0.1);
          
          let durationMs = note.d * (60000 / this.bpm);
          this.nextNoteTime = millis() + durationMs;
          
          this.currentNote++;
          if (this.currentNote >= this.melody.length) this.currentNote = 0;
        }
      }
    }

    // --- Crisp & Quiet Light Sound ---
    function playMagicSound() {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      if (millis() - lastSoundTime < 150) return;
      lastSoundTime = millis();

      const now = audioCtx.currentTime;
      const baseFreq = 1046.50; 
      const ratios = [1, 1.5]; 
      
      ratios.forEach((ratio, index) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.type = 'sine';
        
        const noteFreq = baseFreq * ratio;
        osc.frequency.setValueAtTime(noteFreq, now + index * 0.05); 

        const startTime = now + index * 0.05;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.05, startTime + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.5); 

        osc.start(startTime);
        osc.stop(startTime + 0.5);
      });
    }

    // --- Helper: Coordinate Conversion ---
    function screenToWorld(sx, sy) {
      return {
        x: (sx - view.x) / view.scale,
        y: (sy - view.y) / view.scale
      };
    }

    function draw() {
      background(11, 16, 24);
      
      // Apply View Transformation (Zoom/Pan)
      push();
      translate(view.x, view.y);
      scale(view.scale);

      // Draw Scene
      if (bgLoaded && bgImage) {
        try { image(bgImage, 0, 0, width, height); } catch(e) { drawProceduralBackground(); }
      } else { drawProceduralBackground(); }

      if(musicBox) musicBox.update();

      updateWindows();

      if (!isEditing) {
        handleHandInteraction(); // Logic needs world coords? Hand logic maps directly to width/height, might be offset if zoomed.
        // Actually, hand logic maps video to canvas width/height. 
        // If we zoom, the canvas logical size is same, but we are looking at a subset.
        // We should probably keep hand interaction separate or allow hand to reach everywhere.
        // For simplicity, hand snow summoning works in World Coordinates.
        updateSnowflakes();
      }
      
      pop(); // End View Transform

      // UI Overlays (Screen Space)
      if (isEditing) {
        // Darken overlay
        fill(0, 100); rect(0,0,width,height);
        
        // "Edit Mode" Text
        fill(255, 200); noStroke(); textAlign(CENTER); textSize(14);
        text("Edit Mode Active", width/2, 40);
        
        // Zoom Level Indicator
        if (view.scale !== 1) {
          textSize(12); fill(255, 150);
          text(`Zoom: ${view.scale.toFixed(1)}x`, width/2, 60);
        }
      }
    }

    // --- Logic ---
    function handleHandInteraction() {
      if (hands.length > 0 && video && video.width) {
        const hand = hands[0];
        if (!isHandOpen(hand)) return; 

        let rawX = (hand.landmarks[5][0] + hand.landmarks[17][0]) / 2;
        let rawY = (hand.landmarks[5][1] + hand.landmarks[17][1]) / 2;
        // Map video to canvas (World Space)
        let x = map(rawX, 0, video.width, width, 0); 
        let y = map(rawY, 0, video.height, 0, height);
        
        drawMagicCursor(x, y);
        if (frameCount % 4 === 0) {
          const count = floor(random(2, 5));
          for (let i = 0; i < count; i++) snowflakes.push(new Snowflake(x, y));
        }
      }
    }

    function isHandOpen(hand) {
      const landmarks = hand.landmarks;
      const dist = (p1, p2) => Math.sqrt(Math.pow(p1[0]-p2[0], 2) + Math.pow(p1[1]-p2[1], 2));
      const wrist = landmarks[0];
      const middleTip = landmarks[12];
      const middleBase = landmarks[9];
      return (dist(wrist, middleTip) / dist(wrist, middleBase)) > CONFIG.openHandThreshold;
    }

    function drawMagicCursor(x, y) {
      push(); translate(x, y); noStroke();
      fill(255, 215, 0, 20); circle(0, 0, 50);
      fill(255, 255, 200); circle(0, 0, 6);
      pop();
    }

    // --- Inputs & Zoom Logic ---
    
    // Mouse Wheel Zoom
    function mouseWheel(event) {
      if (!isEditing) return;
      let e = -event.delta;
      let factor = Math.pow(1.01, e);
      zoomAt(mouseX, mouseY, factor);
      return false; // Prevent browser scroll
    }

    function zoomAt(cx, cy, factor) {
      let newScale = constrain(view.scale * factor, view.minScale, view.maxScale);
      factor = newScale / view.scale; 

      view.x = cx - (cx - view.x) * factor;
      view.y = cy - (cy - view.y) * factor;
      view.scale = newScale;
    }

    function mousePressed() { handleInputStart(mouseX, mouseY); }
    
    function touchStarted() { 
      if (touches.length === 2 && isEditing) {
        // Init pinch
        prevPinchDist = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
      } else if (touches.length === 1) {
        handleInputStart(touches[0].x, touches[0].y);
      }
      // return false; // Don't block default too aggressively or UI buttons might fail
    }

    function handleInputStart(mx, my) {
      if (!isEditing) return;
      
      // Convert screen click to world click for object detection
      const world = screenToWorld(mx, my);
      const wx = world.x;
      const wy = world.y;

      // Check Windows
      longPressTimer = setTimeout(() => {
        for (let w of windows) {
          if (w.contains(wx, wy)) { w.toggleShape(); break; }
        }
      }, 600); 

      let hitWindow = false;
      
      // Check Resize Corner
      for (let w of windows) {
        if (w.isCornerHover(wx, wy)) { resizingWindow = w; hitWindow = true; return; }
      }
      
      // Check Drag Window
      if (!hitWindow) {
        for (let i = windows.length - 1; i >= 0; i--) {
          let w = windows[i];
          if (w.contains(wx, wy)) {
            if (mouseButton === RIGHT) { w.toggleShape(); return; }
            draggingWindow = w; 
            dragOffset.x = wx - w.getPixelX(); 
            dragOffset.y = wy - w.getPixelY(); 
            hitWindow = true;
            return;
          }
        }
      }

      // If nothing hit, start Panning the View
      if (!hitWindow) {
        draggingView = true;
        dragStart.x = mx;
        dragStart.y = my;
      }
    }

    function mouseDragged() { 
      // Mouse dragging is single pointer
      handleInputMove(mouseX, mouseY, false); 
    }
    
    function touchMoved() { 
      if (touches.length === 2 && isEditing) {
        // Pinch Zoom Logic
        let currDist = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
        let cx = (touches[0].x + touches[1].x) / 2;
        let cy = (touches[0].y + touches[1].y) / 2;
        
        if (prevPinchDist > 0) {
          let factor = currDist / prevPinchDist;
          zoomAt(cx, cy, factor);
        }
        prevPinchDist = currDist;
        return false;
      } else if (touches.length === 1) {
        handleInputMove(touches[0].x, touches[0].y, true); 
        return false; 
      }
    }

    function handleInputMove(mx, my, isTouch) {
      if (!isEditing) return;
      if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }

      const world = screenToWorld(mx, my);

      if (resizingWindow) {
        let newW = world.x - resizingWindow.getPixelX();
        let newH = world.y - resizingWindow.getPixelY();
        resizingWindow.setPixelSize(max(10, newW), max(10, newH));
      } else if (draggingWindow) {
        draggingWindow.setPixelPos(world.x - dragOffset.x, world.y - dragOffset.y);
      } else if (draggingView) {
        // Panning: delta in screen space maps 1:1 to view translation
        let dx = mx - dragStart.x;
        let dy = my - dragStart.y;
        view.x += dx;
        view.y += dy;
        dragStart.x = mx;
        dragStart.y = my;
      }
    }

    function mouseReleased() { clearInput(); }
    function touchEnded() { 
        clearInput(); 
        prevPinchDist = -1; // reset pinch
    }
    
    function clearInput() {
      draggingWindow = null; resizingWindow = null; draggingView = false;
      if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    }
    
    function doubleClicked() { handleDoubleInput(mouseX, mouseY); }
    function handleDoubleInput(mx, my) {
      if (!isEditing) return;
      
      const world = screenToWorld(mx, my);
      const wx = world.x;
      const wy = world.y;

      for (let i = windows.length - 1; i >= 0; i--) {
        if (windows[i].contains(wx, wy)) { windows.splice(i, 1); return; }
      }
      windows.push(new Window(wx/width, wy/height, 0.08, 0.08));
    }

    // --- Classes ---
    class Window {
      constructor(nx, ny, nw, nh) {
        this.nx = nx; this.ny = ny; this.nw = nw; this.nh = nh;
        this.brightness = 0; this.state = 'IDLE'; this.timer = 0; this.shape = 'RECT'; 
      }
      // Note: getPixelX/Y/W/H returns coordinates in "World Space" (0 to width)
      getPixelX() { return this.nx * width; }
      getPixelY() { return this.ny * height; }
      getPixelW() { return this.nw * width; }
      getPixelH() { return this.nh * height; }
      setPixelPos(px, py) { this.nx = px / width; this.ny = py / height; }
      setPixelSize(pw, ph) { this.nw = pw / width; this.nh = ph / height; }
      toggleShape() { this.shape = (this.shape === 'RECT') ? 'CIRCLE' : 'RECT'; }
      contains(px, py) {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        return px > x && px < x + w && py > y && py < y + h;
      }
      isCornerHover(px, py) {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        // Corner hit size should be constant in Screen Space? 
        // Currently defined in World Space (25px). If zoomed out, it becomes harder to hit. 
        // If zoomed in, easier. This is acceptable behavior.
        return dist(px, py, x + w, y + h) < 25; 
      }
      trigger() {
        if (this.state === 'IDLE' || this.state === 'FADING') {
          this.state = 'TRIGGERED'; this.timer = 0; playMagicSound();
        }
      }
      update() {
        if(isEditing) { this.brightness = 0.5; return; }
        this.timer++;
        switch (this.state) {
          case 'IDLE': this.brightness = 0; break;
          case 'TRIGGERED':
            this.brightness = min(1, this.timer / 60); 
            if (this.brightness >= 1) { this.state = 'SUSTAIN'; this.timer = 0; }
            break;
          case 'SUSTAIN':
            this.brightness = 1; if (this.timer > 60) { this.state = 'FADING'; this.timer = 0; }
            break;
          case 'FADING':
            this.brightness = max(0, 1 - this.timer / 30); if (this.brightness <= 0) this.state = 'IDLE';
            break;
        }
      }
      display() {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        
        if (isEditing) {
          stroke(255, 200); strokeWeight(1); fill(255, 200, 100, 50);
          if (this.shape === 'CIRCLE') {
             rect(x, y, w, h); 
             fill(255, 220, 100, 150); 
             ellipse(x + w/2, y + h/2, w, h); 
          } else { rect(x, y, w, h); }
          noStroke(); fill(255); circle(x + w, y + h, 12); return;
        }

        if (this.brightness > 0.01) {
          push();
          const alpha = this.brightness * 255;
          const cx = x + w/2; const cy = y + h/2;
          
          drawingContext.filter = 'blur(15px)'; 
          fill(255, 180, 60, alpha * 0.4);
          if (this.shape === 'CIRCLE') ellipse(cx, cy, w*1.2, h*1.2);
          else rect(x - w*0.1, y - h*0.1, w*1.2, h*1.2);

          drawingContext.filter = 'blur(4px)';
          fill(255, 240, 180, alpha * 0.9);
          if (this.shape === 'CIRCLE') ellipse(cx, cy, w*0.85, h*0.85);
          else rect(x + w*0.1, y + h*0.1, w*0.8, h*0.8); 

          pop();
        }
      }
    }

    class Snowflake {
      constructor(x, y) {
        this.x = x + random(-10, 10); this.y = y;
        this.vx = random(-1, 1); this.vy = random(1, 3);
        this.size = random(2, 5); this.alpha = random(150, 255);
        this.active = true; this.wobble = random(100);
      }
      update() {
        this.wobble += 0.05; this.vx += sin(this.wobble) * 0.05;
        this.y += this.vy; this.x += this.vx;
        for (let w of windows) { if (w.contains(this.x, this.y)) { w.trigger(); this.active = false; return; } }
        if (this.y > height || this.x < 0 || this.x > width) this.active = false;
      }
      display() { noStroke(); fill(255, this.alpha); circle(this.x, this.y, this.size); }
    }

    function updateWindows() { windows.forEach(w => { w.update(); w.display(); }); }
    function updateSnowflakes() {
      for (let i = snowflakes.length - 1; i >= 0; i--) {
        snowflakes[i].update(); snowflakes[i].display();
        if (!snowflakes[i].active) snowflakes.splice(i, 1);
      }
      if (snowflakes.length > CONFIG.maxSnowflakes) snowflakes.splice(0, snowflakes.length - CONFIG.maxSnowflakes);
    }

    function initWindows() {
      windows = [
        new Window(0.15, 0.6, 0.03, 0.04), new Window(0.2, 0.6, 0.03, 0.04),
        new Window(0.35, 0.7, 0.04, 0.05), new Window(0.42, 0.7, 0.04, 0.05), 
        new Window(0.78, 0.75, 0.04, 0.05)
      ];
    }

    function initStars() { for(let i=0; i<80; i++) stars.push({x: random(2000), y: random(1000), s: random(1, 3), a: random(100, 255)}); }
    function drawProceduralBackground() {
      for (let y = 0; y < height; y++) {
        let c = lerpColor(color(10, 15, 30), color(40, 50, 80), map(y, 0, height, 0, 1));
        stroke(c); line(0, y, width, y);
      }
      noStroke();
      stars.forEach(s => { fill(255, s.a); circle(s.x % width, s.y % height, s.s); });
      fill(15, 20, 30); beginShape();
      vertex(0, height); vertex(0, height*0.7); vertex(width*0.5, height*0.8); vertex(width, height*0.75); vertex(width, height);
      endShape(CLOSE);
    }

    function updateUIStatus(id, active, text) {
      document.getElementById(`${id}-dot`).classList.toggle('active', active);
      document.getElementById(`${id}-status`).innerText = text;
    }
  </script>
</body>
</html>
