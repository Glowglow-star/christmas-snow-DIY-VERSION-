<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Optimize viewport for mobile devices -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Snowy Christmas Night | Interactive Art</title>
  
  <!-- Libraries -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>
  
  <style>
    /* --- Base Styles --- */
    :root {
      --glass-bg: rgba(16, 20, 30, 0.85);
      --glass-border: rgba(255, 255, 255, 0.12);
      --accent: #FFD700;
      --accent-blue: #60a5fa;
      --text-color: #F0F4F8;
    }

    body {
      margin: 0; padding: 0; background-color: #05070a;
      background: radial-gradient(circle at center, #1a1f2e 0%, #05070a 100%);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      overflow: hidden; 
      display: flex; 
      justify-content: center; 
      align-items: center;
      height: 100vh; 
      color: var(--text-color); 
      user-select: none; -webkit-user-select: none; touch-action: none;
    }

    /* Canvas Container */
    #canvas-container {
      position: relative; 
      box-shadow: 0 20px 80px rgba(0,0,0,0.6), 0 0 0 1px rgba(255,255,255,0.1);
      border-radius: 16px; 
      overflow: hidden; 
      line-height: 0;
      width: auto; height: auto;
      max-width: 100vw; max-height: 100vh;
      background: #000;
    }
    
    canvas { display: block; }

    @media (min-width: 768px) {
      #canvas-container {
        border-radius: 20px;
        max-width: 95vw; max-height: 95vh;
      }
    }

    /* --- UI Elements --- */
    #start-screen {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(5, 8, 16, 0.85); 
      backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px);
      z-index: 100; display: flex; flex-direction: column;
      justify-content: center; align-items: center;
      transition: opacity 0.8s ease-out;
      padding: 30px; box-sizing: border-box; text-align: center;
    }

    h1 {
      font-weight: 200; font-size: clamp(2rem, 5vw, 3rem); 
      letter-spacing: 3px; margin-bottom: 8px;
      background: linear-gradient(to bottom right, #fff, #a5b4fc);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      text-shadow: 0 0 30px rgba(165, 180, 252, 0.3);
    }

    p.subtitle { 
      color: #94a3b8; margin-bottom: 40px; 
      font-size: 1rem; letter-spacing: 1px; font-weight: 300;
    }

    .btn-group { 
      display: flex; gap: 12px; flex-direction: column; 
      align-items: center; width: 100%; max-width: 320px; 
    }

    .ui-btn {
      position: relative;
      width: 100%; padding: 16px 24px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: white; border-radius: 16px;
      cursor: pointer; font-size: 16px; font-weight: 500; letter-spacing: 0.5px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex; align-items: center; justify-content: center; gap: 12px;
      backdrop-filter: blur(5px);
    }
    
    .ui-btn:active { transform: scale(0.98); background: rgba(255,255,255,0.08); }
    .upload-btn { border-color: rgba(255, 215, 0, 0.2); color: #ffeba0; background: rgba(255, 215, 0, 0.05); }
    .audio-btn { border-color: rgba(96, 165, 250, 0.2); color: #bfdbfe; background: rgba(96, 165, 250, 0.05); }

    #start-btn { 
      background: rgba(255, 255, 255, 0.95); 
      color: #0b1018; border: none;
      font-weight: 600; margin-top: 10px;
      opacity: 0.5; pointer-events: none;
      box-shadow: 0 0 25px rgba(255, 255, 255, 0.15);
    }
    #start-btn.ready { opacity: 1; pointer-events: auto; }

    #file-input, #audio-input { display: none; }
    
    .status-container { display: flex; flex-direction: column; gap: 4px; margin-bottom: 10px; }
    .file-status { font-size: 12px; color: #64748b; height: 16px; }

    /* --- Overlays --- */
    #left-ui-container {
      position: absolute; top: 20px; left: 20px; z-index: 10;
      display: flex; flex-direction: column; gap: 10px;
      align-items: flex-start; pointer-events: none; 
    }
    @media (max-width: 600px) {
      #left-ui-container { transform: scale(0.9); transform-origin: top left; left: 16px; top: 16px; }
    }

    .status-badge {
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      padding: 6px 14px; border-radius: 20px; font-size: 12px;
      backdrop-filter: blur(10px); display: flex; align-items: center; gap: 8px; width: fit-content; pointer-events: auto;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
    }
    .dot { width: 6px; height: 6px; border-radius: 50%; background-color: #ef4444; transition: all 0.5s; }
    .dot.active { background-color: #4ade80; box-shadow: 0 0 6px #4ade80; }

    .hint-text {
      background: rgba(0, 0, 0, 0.6); border: 1px solid rgba(255,255,255,0.15);
      padding: 8px 16px; border-radius: 20px; font-size: 13px; color: rgba(255,255,255,0.95);
      backdrop-filter: blur(8px); opacity: 0; transition: opacity 1s; margin-top: 5px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
    }

    #top-right-controls {
      position: absolute; top: 20px; right: 20px;
      z-index: 20; opacity: 0; transition: opacity 1s; display: flex; gap: 12px;
    }
    @media (max-width: 600px) {
      #top-right-controls { top: 16px; right: 16px; transform: scale(0.9); transform-origin: top right; }
    }
    
    .icon-btn {
      background: var(--glass-bg); border: 1px solid var(--glass-border);
      color: rgba(255,255,255,0.9); padding: 10px 16px; border-radius: 24px;
      cursor: pointer; font-size: 13px; backdrop-filter: blur(10px);
      display: flex; align-items: center; gap: 6px; transition: all 0.2s;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2); font-weight: 500;
    }
    .icon-btn:active { transform: scale(0.95); background: rgba(255,255,255,0.15); }
    .icon-btn.active { 
      background: rgba(255, 215, 0, 0.15); border-color: rgba(255, 215, 0, 0.4); color: #ffe066; 
    }
    #music-toggle.playing { color: #86efac; border-color: rgba(134, 239, 172, 0.3); background: rgba(134, 239, 172, 0.1); }

    #edit-tips {
      background: var(--glass-bg); color: #cbd5e1; padding: 16px; 
      border-radius: 16px; font-size: 12px; display: none; 
      pointer-events: auto; border: 1px solid var(--glass-border);
      box-shadow: 0 10px 40px rgba(0,0,0,0.4); margin-top: 12px;
    }
    .tips-container { display: flex; flex-direction: column; gap: 10px; align-items: flex-start; }
    .tip-item { display: flex; align-items: center; gap: 10px; }
    .key {
      color: var(--accent); font-weight: 700; font-size: 11px; 
      background: rgba(255, 215, 0, 0.1); padding: 3px 8px; border-radius: 6px;
      border: 1px solid rgba(255, 215, 0, 0.1); text-transform: uppercase;
    }

    .loader { width: 40px; height: 40px; border: 3px solid rgba(255,255,255,0.1); border-radius: 50%; border-top-color: #fff; animation: spin 1s ease-in-out infinite; display: none; margin-bottom: 30px; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>

  <div id="canvas-container">
    
    <div id="left-ui-container">
      <div class="status-badge"><div class="dot" id="cam-dot"></div><span id="cam-status">Waiting for Camera...</span></div>
      <div class="status-badge"><div class="dot" id="model-dot"></div><span id="model-status">Loading AI...</span></div>
      <div id="hint-overlay" class="hint-text">âœ¨ Open your hand to summon snow âœ¨</div>
      
      <div id="edit-tips">
        <div class="tips-container">
          <div class="tip-item"><span class="key">Tap</span> Select</div>
          <div class="tip-item"><span class="key">Drag Center</span> Move</div>
          <div class="tip-item"><span class="key">Drag Corner</span> Resize</div>
          <div class="tip-item"><span class="key">Double Tap</span> Add / Delete</div>
          <div class="tip-item"><span class="key">Hold</span> Toggle Shape</div>
        </div>
      </div>
    </div>

    <div id="top-right-controls">
      <button id="music-toggle" class="icon-btn"><span>ðŸŽµ</span> BGM</button>
      <button id="edit-mode-btn" class="icon-btn"><span>ðŸ”§</span> Edit</button>
    </div>

    <div id="start-screen">
      <h1>Silent Night</h1>
      <p class="subtitle">Interactive Christmas Experience</p>
      <div class="loader" id="loader"></div>
      
      <div class="btn-group" id="controls">
        <label for="file-input" class="ui-btn upload-btn"><span>ðŸ“·</span> Select Image</label>
        <input type="file" id="file-input" accept="image/*">
        
        <label for="audio-input" class="ui-btn audio-btn"><span>ðŸŽµ</span> Select BGM (Optional)</label>
        <input type="file" id="audio-input" accept="audio/*">

        <div class="status-container">
          <div id="img-status" class="file-status">No image selected</div>
          <div id="audio-status" class="file-status">Using built-in music</div>
        </div>
        
        <button id="start-btn" class="ui-btn">Start</button>
      </div>
    </div>
  </div>

  <script>
    // --- Global Variables ---
    let handpose, video;
    let hands = [];
    let bgImage = null;
    let bgLoaded = false;
    let snowflakes = [], windows = [], stars = [];
    let isModelReady = false, isCamReady = false;
    
    let audioCtx, lastSoundTime = 0, musicBox, customBGM = null;
    
    // Edit Mode State
    let isEditing = false;
    let selectedWindow = null; // Currently selected window
    let interactionState = 'NONE'; // NONE, MOVING, RESIZING, PANNING
    let resizeHandle = -1; // 0:TL, 1:TR, 2:BR, 3:BL
    
    // View Transform
    let view = { x: 0, y: 0, scale: 1, minScale: 0.5, maxScale: 4.0 };
    let dragStart = { x: 0, y: 0 }; 
    let dragOffset = { x: 0, y: 0 };
    let prevPinchDist = -1;
    let longPressTimer = null;
    let lastTapTime = 0; // For custom double tap

    const CONFIG = { 
      maxSnowflakes: 120,
      openHandThreshold: 1.2,
      bgmVolume: 0.08
    };

    function setup() {
      const screenW = window.innerWidth;
      const screenH = window.innerHeight;
      const cnv = createCanvas(screenW, screenH);
      cnv.parent('canvas-container');
      
      document.addEventListener('contextmenu', event => event.preventDefault());

      initWindows(); 
      initStars();
      musicBox = new MusicBox();
      
      noLoop();
      bindEvents();
    }

    function bindEvents() {
      const fileInput = document.getElementById('file-input');
      const audioInput = document.getElementById('audio-input');
      const imgStatus = document.getElementById('img-status');
      const audioStatus = document.getElementById('audio-status');
      const startBtn = document.getElementById('start-btn');
      const editBtn = document.getElementById('edit-mode-btn');
      const musicBtn = document.getElementById('music-toggle');

      editBtn.addEventListener('click', () => {
        isEditing = !isEditing;
        editBtn.classList.toggle('active');
        document.getElementById('edit-tips').style.display = isEditing ? 'block' : 'none';
        editBtn.innerHTML = isEditing ? "<span>âœ…</span> Done" : "<span>ðŸ”§</span> Edit";
        
        if (!isEditing) {
          selectedWindow = null; // Deselect on exit
          view = { x: 0, y: 0, scale: 1, minScale: 0.5, maxScale: 4.0 }; // Reset zoom
        }
      });

      musicBtn.addEventListener('click', () => {
        userStartAudio();
        if (customBGM) {
          if (customBGM.isPlaying()) {
            customBGM.pause();
            musicBtn.classList.remove('playing');
          } else {
            musicBox.stop();
            customBGM.loop();
            customBGM.setVolume(0.5);
            musicBtn.classList.add('playing');
          }
        } else {
          if (!musicBox.isPlaying) {
            musicBox.play();
            musicBtn.classList.add('playing');
          } else {
            musicBox.stop();
            musicBtn.classList.remove('playing');
          }
        }
      });

      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          loadImage(url, (img) => {
            bgImage = img;
            bgLoaded = true;
            
            const screenW = window.innerWidth;
            const screenH = window.innerHeight;
            const scaleW = (screenW * 0.95) / img.width;
            const scaleH = (screenH * 0.95) / img.height;
            const scale = Math.min(scaleW, scaleH);
            
            const finalW = img.width * scale;
            const finalH = img.height * scale;
            resizeCanvas(finalW, finalH);

            initWindows(); 
            imgStatus.innerText = `Image: ${file.name}`;
            imgStatus.style.color = "#86efac";
            startBtn.classList.add('ready');
          });
        }
      });

      audioInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file) {
          const url = URL.createObjectURL(file);
          loadSound(url, (sound) => {
            customBGM = sound;
            audioStatus.innerText = `Music: ${file.name}`;
            audioStatus.style.color = "#93c5fd";
          });
        }
      });

      startBtn.classList.add('ready'); 
      startBtn.addEventListener('click', initializeApp);
    }

    async function initializeApp() {
      try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
      } catch(e) { console.log("Web Audio API Error"); }

      document.getElementById('controls').style.display = 'none';
      document.getElementById('loader').style.display = 'block';
      document.querySelector('#start-screen p').innerText = "Initializing...";

      try {
        const constraints = { video: { facingMode: "user" }, audio: false };
        video = createCapture(constraints, function(stream) {
          isCamReady = true;
          updateUIStatus('cam', true, "Camera Active");
        });
        
        if (video) {
            video.size(width, height);
            video.hide();
            handpose = ml5.handpose(video, () => {
                isModelReady = true;
                updateUIStatus('model', true, "AI Ready");
                
                const startScreen = document.getElementById('start-screen');
                startScreen.style.opacity = 0;
                setTimeout(() => startScreen.style.display = 'none', 800);
                
                document.getElementById('hint-overlay').style.opacity = 1;
                document.getElementById('top-right-controls').style.opacity = 1;
                loop();
            });
            handpose.on("predict", results => hands = results);
        } else { alert("Camera access failed. Ensure HTTPS."); }
      } catch (err) { console.error(err); alert("Error: " + err.message); }
    }

    // --- Audio Classes ---
    class MusicBox {
      constructor() {
        this.osc = new p5.Oscillator('sine'); 
        this.env = new p5.Envelope();
        this.env.setADSR(0.2, 0.3, 0.1, 0.8); 
        this.env.setRange(CONFIG.bgmVolume, 0);
        this.osc.start(); this.osc.amp(0);
        this.isPlaying = false; this.currentNote = 0; this.bpm = 75; this.nextNoteTime = 0;
        this.melody = [
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }, 
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }, 
          { n: 587.33, d: 2.0 }, { n: 587.33, d: 1.0 }, { n: 493.88, d: 3.0 }, 
          { n: 523.25, d: 2.0 }, { n: 523.25, d: 1.0 }, { n: 392.00, d: 3.0 }, 
          { n: 440.00, d: 2.0 }, { n: 440.00, d: 1.0 }, { n: 523.25, d: 1.5 }, { n: 493.88, d: 0.5 }, { n: 440.00, d: 1.0 },
          { n: 392.00, d: 1.5 }, { n: 440.00, d: 0.5 }, { n: 392.00, d: 1.0 }, { n: 329.63, d: 3.0 }
        ];
      }
      play() { this.isPlaying = true; this.currentNote = 0; this.nextNoteTime = millis(); this.osc.amp(0); }
      stop() { this.isPlaying = false; this.osc.amp(0); }
      update() {
        if (!this.isPlaying) return;
        if (millis() >= this.nextNoteTime) {
          let note = this.melody[this.currentNote];
          this.osc.freq(note.n + random(-1, 1));
          this.env.play(this.osc, 0, 0.1);
          let durationMs = note.d * (60000 / this.bpm);
          this.nextNoteTime = millis() + durationMs;
          this.currentNote++;
          if (this.currentNote >= this.melody.length) this.currentNote = 0;
        }
      }
    }

    function playMagicSound() {
      if (!audioCtx) return;
      if (audioCtx.state === 'suspended') audioCtx.resume();
      if (millis() - lastSoundTime < 150) return;
      lastSoundTime = millis();
      const now = audioCtx.currentTime;
      [1, 1.5].forEach((ratio, index) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain); gain.connect(audioCtx.destination);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1046.50 * ratio, now + index * 0.05); 
        const startTime = now + index * 0.05;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.05, startTime + 0.02); 
        gain.gain.exponentialRampToValueAtTime(0.0001, startTime + 0.5); 
        osc.start(startTime); osc.stop(startTime + 0.5);
      });
    }

    // --- Drawing ---
    function screenToWorld(sx, sy) {
      return { x: (sx - view.x) / view.scale, y: (sy - view.y) / view.scale };
    }

    function draw() {
      background(11, 16, 24);
      
      push();
      translate(view.x, view.y);
      scale(view.scale);

      if (bgLoaded && bgImage) {
        try { image(bgImage, 0, 0, width, height); } catch(e) { drawProceduralBackground(); }
      } else { drawProceduralBackground(); }

      if(musicBox) musicBox.update();
      updateWindows();

      if (!isEditing) {
        handleHandInteraction();
        updateSnowflakes();
      }
      pop();

      if (isEditing) {
        fill(0, 100); rect(0,0,width,height);
        fill(255, 200); noStroke(); textAlign(CENTER); textSize(14);
        text("Edit Mode Active", width/2, 40);
        if (view.scale !== 1) {
          textSize(12); fill(255, 150); text(`Zoom: ${view.scale.toFixed(1)}x`, width/2, 60);
        }
      }
    }

    function handleHandInteraction() {
      if (hands.length > 0 && video && video.width) {
        const hand = hands[0];
        if (!isHandOpen(hand)) return; 
        let rawX = (hand.landmarks[5][0] + hand.landmarks[17][0]) / 2;
        let rawY = (hand.landmarks[5][1] + hand.landmarks[17][1]) / 2;
        let x = map(rawX, 0, video.width, width, 0); 
        let y = map(rawY, 0, video.height, 0, height);
        drawMagicCursor(x, y);
        if (frameCount % 4 === 0) {
          const count = floor(random(2, 5));
          for (let i = 0; i < count; i++) snowflakes.push(new Snowflake(x, y));
        }
      }
    }

    function isHandOpen(hand) {
      const dist = (p1, p2) => Math.sqrt(Math.pow(p1[0]-p2[0], 2) + Math.pow(p1[1]-p2[1], 2));
      return (dist(hand.landmarks[0], hand.landmarks[12]) / dist(hand.landmarks[0], hand.landmarks[9])) > CONFIG.openHandThreshold;
    }

    function drawMagicCursor(x, y) {
      push(); translate(x, y); noStroke();
      fill(255, 215, 0, 20); circle(0, 0, 50);
      fill(255, 255, 200); circle(0, 0, 6);
      pop();
    }

    // --- Input Handling ---
    function mouseWheel(event) {
      if (!isEditing) return;
      let e = -event.delta;
      let factor = Math.pow(1.01, e);
      zoomAt(mouseX, mouseY, factor);
      return false; 
    }

    function zoomAt(cx, cy, factor) {
      let newScale = constrain(view.scale * factor, view.minScale, view.maxScale);
      factor = newScale / view.scale; 
      view.x = cx - (cx - view.x) * factor;
      view.y = cy - (cy - view.y) * factor;
      view.scale = newScale;
    }

    function mousePressed() { handleInputStart(mouseX, mouseY); }
    function touchStarted() { 
      if (!isEditing) return;

      if (touches.length === 2) {
        prevPinchDist = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
      } else if (touches.length === 1) {
        // Custom Double Tap Detection
        const now = millis();
        if (now - lastTapTime < 300) {
          handleDoubleInput(touches[0].x, touches[0].y);
        } else {
          handleInputStart(touches[0].x, touches[0].y);
        }
        lastTapTime = now;
      }
      return false; // Critical for mobile: prevent mousePressed firing after touchStarted
    }

    function handleInputStart(mx, my) {
      if (!isEditing) return;
      const world = screenToWorld(mx, my);
      const wx = world.x, wy = world.y;

      // 1. Check Long Press (Toggle Shape)
      longPressTimer = setTimeout(() => {
        if (interactionState === 'NONE') {
           for (let w of windows) {
            if (w.contains(wx, wy)) { w.toggleShape(); break; }
           }
        }
      }, 600); 

      interactionState = 'NONE';
      
      // 2. Check for Resize Handles on SELECTED window ONLY
      if (selectedWindow) {
        let handle = selectedWindow.getHoverHandle(wx, wy);
        if (handle !== -1) {
           interactionState = 'RESIZING';
           resizeHandle = handle;
           return;
        }
      }

      // 3. Check for Click on Windows
      let hitWindow = null;
      for (let i = windows.length - 1; i >= 0; i--) {
        if (windows[i].contains(wx, wy)) { hitWindow = windows[i]; break; }
      }

      if (hitWindow) {
        if (selectedWindow !== hitWindow) {
          // Select new window
          selectedWindow = hitWindow;
        } 
        // Start moving
        interactionState = 'MOVING';
        dragOffset.x = wx - selectedWindow.getPixelX();
        dragOffset.y = wy - selectedWindow.getPixelY();
      } else {
        // Clicked empty space
        selectedWindow = null; // Deselect
        interactionState = 'PANNING';
        dragStart.x = mx; dragStart.y = my;
      }
    }

    function mouseDragged() { handleInputMove(mouseX, mouseY); }
    function touchMoved() { 
      if (!isEditing) return;
      
      if (touches.length === 2) {
        let currDist = dist(touches[0].x, touches[0].y, touches[1].x, touches[1].y);
        let cx = (touches[0].x + touches[1].x) / 2;
        let cy = (touches[0].y + touches[1].y) / 2;
        if (prevPinchDist > 0) {
          let factor = currDist / prevPinchDist;
          zoomAt(cx, cy, factor);
        }
        prevPinchDist = currDist;
      } else if (touches.length === 1) {
        handleInputMove(touches[0].x, touches[0].y); 
      }
      return false; // Prevent scrolling and duplicate events
    }

    function handleInputMove(mx, my) {
      if (!isEditing) return;
      if (longPressTimer && (interactionState === 'MOVING' || interactionState === 'RESIZING' || interactionState === 'PANNING')) {
        clearTimeout(longPressTimer); longPressTimer = null;
      }

      const world = screenToWorld(mx, my);

      if (interactionState === 'RESIZING' && selectedWindow) {
        selectedWindow.resizeByHandle(world.x, world.y, resizeHandle);
      } else if (interactionState === 'MOVING' && selectedWindow) {
        selectedWindow.setPixelPos(world.x - dragOffset.x, world.y - dragOffset.y);
      } else if (interactionState === 'PANNING') {
        let dx = mx - dragStart.x;
        let dy = my - dragStart.y;
        view.x += dx; view.y += dy;
        dragStart.x = mx; dragStart.y = my;
      }
    }

    function mouseReleased() { clearInput(); }
    function touchEnded() { 
      clearInput(); 
      prevPinchDist = -1; 
      return false; // Prevent default behavior
    }
    
    function clearInput() {
      interactionState = 'NONE';
      if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
    }
    
    // Desktop Double Click
    function doubleClicked() { 
       if(!('ontouchstart' in window)) handleDoubleInput(mouseX, mouseY); 
    }
    
    function handleDoubleInput(mx, my) {
      if (!isEditing) return;
      const world = screenToWorld(mx, my);
      const wx = world.x, wy = world.y;

      let hit = false;
      for (let i = windows.length - 1; i >= 0; i--) {
        if (windows[i].contains(wx, wy)) {
           // Delete window
           windows.splice(i, 1);
           selectedWindow = null;
           hit = true;
           break;
        }
      }
      
      if (!hit) {
        // Add new window
        let newWin = new Window(wx/width, wy/height, 0.08, 0.08);
        windows.push(newWin);
        selectedWindow = newWin; // Auto select new window
      }
    }

    // --- Classes ---
    class Window {
      constructor(nx, ny, nw, nh) {
        this.nx = nx; this.ny = ny; this.nw = nw; this.nh = nh;
        this.brightness = 0; this.state = 'IDLE'; this.timer = 0; this.shape = 'RECT'; 
      }
      getPixelX() { return this.nx * width; }
      getPixelY() { return this.ny * height; }
      getPixelW() { return this.nw * width; }
      getPixelH() { return this.nh * height; }
      setPixelPos(px, py) { this.nx = px / width; this.ny = py / height; }
      setPixelSize(pw, ph) { this.nw = pw / width; this.nh = ph / height; }
      
      contains(px, py) {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        return px > x && px < x + w && py > y && py < y + h;
      }

      getHoverHandle(px, py) {
        // Returns 0:TL, 1:TR, 2:BR, 3:BL, -1:None
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        // Larger touch target for mobile: 45 instead of 30
        let r = 45 / view.scale; 
        
        if (dist(px, py, x, y) < r) return 0;
        if (dist(px, py, x + w, y) < r) return 1;
        if (dist(px, py, x + w, y + h) < r) return 2;
        if (dist(px, py, x, y + h) < r) return 3;
        return -1;
      }
      
      resizeByHandle(mx, my, handle) {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        let nx = x, ny = y, nw = w, nh = h;
        
        if (handle === 0) { // TL
           nw = (x + w) - mx; nh = (y + h) - my; nx = mx; ny = my;
        } else if (handle === 1) { // TR
           nw = mx - x; nh = (y + h) - my; ny = my;
        } else if (handle === 2) { // BR
           nw = mx - x; nh = my - y;
        } else if (handle === 3) { // BL
           nw = (x + w) - mx; nh = my - y; nx = mx;
        }
        
        // Min size constraint
        if (nw > 10 && nh > 10) {
            this.setPixelPos(nx, ny);
            this.setPixelSize(nw, nh);
        }
      }

      toggleShape() { this.shape = (this.shape === 'RECT') ? 'CIRCLE' : 'RECT'; }
      
      trigger() {
        if (this.state === 'IDLE' || this.state === 'FADING') {
          this.state = 'TRIGGERED'; this.timer = 0; playMagicSound();
        }
      }
      
      update() {
        if(isEditing) { this.brightness = 0.5; return; }
        this.timer++;
        switch (this.state) {
          case 'IDLE': this.brightness = 0; break;
          case 'TRIGGERED':
            this.brightness = min(1, this.timer / 60); 
            if (this.brightness >= 1) { this.state = 'SUSTAIN'; this.timer = 0; }
            break;
          case 'SUSTAIN':
            this.brightness = 1; if (this.timer > 60) { this.state = 'FADING'; this.timer = 0; }
            break;
          case 'FADING':
            this.brightness = max(0, 1 - this.timer / 30); if (this.brightness <= 0) this.state = 'IDLE';
            break;
        }
      }
      
      display() {
        let x = this.getPixelX(), y = this.getPixelY(), w = this.getPixelW(), h = this.getPixelH();
        
        if (isEditing) {
          // Edit Mode Visuals
          let isSel = (selectedWindow === this);
          
          strokeWeight(2 / view.scale);
          if (isSel) {
            stroke(0, 255, 200); // Bright Teal for Selected
            fill(0, 255, 200, 40);
          } else {
            stroke(255, 100); // Faint White for others
            fill(255, 20);
          }
          
          if (this.shape === 'CIRCLE') ellipse(x + w/2, y + h/2, w, h);
          else rect(x, y, w, h);
          
          // Draw Handles if selected
          if (isSel) {
             noStroke(); fill(0, 255, 200);
             let r = 12 / view.scale; // Larger visual handles
             circle(x, y, r); // TL
             circle(x + w, y, r); // TR
             circle(x + w, y + h, r); // BR
             circle(x, y + h, r); // BL
          }
          return;
        }

        // Play Mode Visuals (Gradient Approach)
        if (this.brightness > 0.01) {
          push();
          const alpha = this.brightness;
          const cx = x + w / 2;
          const cy = y + h / 2;
          const ctx = drawingContext;

          // 1. Create Radial Gradient for Glow
          // Center (cx, cy) to Outer Edge (radius)
          let radius = max(w, h) * 2.0; // Large glow radius
          let gradient = ctx.createRadialGradient(cx, cy, 0, cx, cy, radius);
          
          // Gradient Colors: Core (White/Yellow) -> Mid (Orange) -> Edge (Transparent)
          // Adjust these colors to match the warm orange preference
          gradient.addColorStop(0, `rgba(255, 240, 200, ${alpha})`);
          gradient.addColorStop(0.2, `rgba(255, 180, 60, ${alpha * 0.8})`);
          gradient.addColorStop(0.5, `rgba(255, 120, 20, ${alpha * 0.3})`);
          gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();

          // 2. Draw the actual Window Shape (The "Source" of light)
          fill(255, 230, 180, alpha * 200); // p5 fill (0-255 alpha)
          noStroke();
          if (this.shape === 'CIRCLE') ellipse(cx, cy, w * 0.8, h * 0.8);
          else rect(x + w*0.1, y + h*0.1, w * 0.8, h * 0.8);

          pop();
        }
      }
    }

    class Snowflake {
      constructor(x, y) {
        this.x = x + random(-10, 10); this.y = y;
        this.vx = random(-1, 1); this.vy = random(1, 3);
        this.size = random(2, 5); this.alpha = random(150, 255);
        this.active = true; this.wobble = random(100);
      }
      update() {
        this.wobble += 0.05; this.vx += sin(this.wobble) * 0.05;
        this.y += this.vy; this.x += this.vx;
        for (let w of windows) { if (w.contains(this.x, this.y)) { w.trigger(); this.active = false; return; } }
        if (this.y > height || this.x < 0 || this.x > width) this.active = false;
      }
      display() { noStroke(); fill(255, this.alpha); circle(this.x, this.y, this.size); }
    }

    function updateWindows() { windows.forEach(w => { w.update(); w.display(); }); }
    function updateSnowflakes() {
      for (let i = snowflakes.length - 1; i >= 0; i--) {
        snowflakes[i].update(); snowflakes[i].display();
        if (!snowflakes[i].active) snowflakes.splice(i, 1);
      }
      if (snowflakes.length > CONFIG.maxSnowflakes) snowflakes.splice(0, snowflakes.length - CONFIG.maxSnowflakes);
    }

    function initWindows() {
      windows = [
        new Window(0.15, 0.6, 0.03, 0.04), new Window(0.2, 0.6, 0.03, 0.04),
        new Window(0.35, 0.7, 0.04, 0.05), new Window(0.42, 0.7, 0.04, 0.05), 
        new Window(0.78, 0.75, 0.04, 0.05)
      ];
    }

    function initStars() { for(let i=0; i<80; i++) stars.push({x: random(2000), y: random(1000), s: random(1, 3), a: random(100, 255)}); }
    function drawProceduralBackground() {
      for (let y = 0; y < height; y++) {
        let c = lerpColor(color(10, 15, 30), color(40, 50, 80), map(y, 0, height, 0, 1));
        stroke(c); line(0, y, width, y);
      }
      noStroke();
      stars.forEach(s => { fill(255, s.a); circle(s.x % width, s.y % height, s.s); });
      fill(15, 20, 30); beginShape();
      vertex(0, height); vertex(0, height*0.7); vertex(width*0.5, height*0.8); vertex(width, height*0.75); vertex(width, height);
      endShape(CLOSE);
    }

    function updateUIStatus(id, active, text) {
      document.getElementById(`${id}-dot`).classList.toggle('active', active);
      document.getElementById(`${id}-status`).innerText = text;
    }
  </script>
</body>
</html>
